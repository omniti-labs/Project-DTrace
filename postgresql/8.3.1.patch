Index: src/include/Makefile
===================================================================
--- src/include/Makefile	(revision 30152)
+++ src/include/Makefile	(working copy)
@@ -15,6 +15,10 @@
 
 all: pg_config.h pg_config_os.h
 
+pg_trace.h:	../backend/utils/probes.d
+	$(DTRACE) $(DTRACEFLAGS) -h -s ../backend/utils/probes.d -o pg_trace.h.tmp
+	sed -e 's/#if _DTRACE_VERSION/#ifdef ENABLE_DTRACE/;' < pg_trace.h.tmp > pg_trace.h
+	rm -f pg_trace.h.tmp
 
 # Subdirectories containing headers for server-side dev
 SUBDIRS = access bootstrap catalog commands executor lib libpq mb \
Index: src/backend/executor/nodeNestloop.c
===================================================================
--- src/backend/executor/nodeNestloop.c	(revision 30152)
+++ src/backend/executor/nodeNestloop.c	(working copy)
@@ -67,6 +67,8 @@
 	List	   *otherqual;
 	ExprContext *econtext;
 
+	POSTGRESQL_EXEC_NESTLOOP((uintptr_t)node);
+
 	/*
 	 * get information from the node
 	 */
Index: src/backend/executor/nodeSubplan.c
===================================================================
--- src/backend/executor/nodeSubplan.c	(revision 30152)
+++ src/backend/executor/nodeSubplan.c	(working copy)
@@ -81,6 +81,8 @@
 	ExprContext *innerecontext = node->innerecontext;
 	TupleTableSlot *slot;
 
+	POSTGRESQL_EXEC_SUBPLAN_HASH((uintptr_t)node);
+
 	/* Shouldn't have any direct correlation Vars */
 	if (subplan->parParam != NIL || node->args != NIL)
 		elog(ERROR, "hashed subplan with direct correlation not supported");
@@ -216,6 +218,8 @@
 	ListCell   *l;
 	ArrayBuildState *astate = NULL;
 
+	POSTGRESQL_EXEC_SUBPLAN_SCAN((uintptr_t)node);
+
 	/*
 	 * We are probably in a short-lived expression-evaluation context. Switch
 	 * to the per-query context for manipulating the child plan's chgParam,
Index: src/backend/executor/nodeUnique.c
===================================================================
--- src/backend/executor/nodeUnique.c	(revision 30152)
+++ src/backend/executor/nodeUnique.c	(working copy)
@@ -45,6 +45,8 @@
 	TupleTableSlot *slot;
 	PlanState  *outerPlan;
 
+	POSTGRESQL_EXEC_UNIQUE((uintptr_t)node);
+
 	/*
 	 * get information from the node
 	 */
Index: src/backend/executor/nodeHash.c
===================================================================
--- src/backend/executor/nodeHash.c	(revision 30152)
+++ src/backend/executor/nodeHash.c	(working copy)
@@ -70,6 +70,8 @@
 	ExprContext *econtext;
 	uint32		hashvalue;
 
+	POSTGRESQL_EXEC_HASH_MULTI((uintptr_t)node);
+
 	/* must provide our own instrumentation support */
 	if (node->ps.instrument)
 		InstrStartNode(node->ps.instrument);
Index: src/backend/executor/nodeSetOp.c
===================================================================
--- src/backend/executor/nodeSetOp.c	(revision 30152)
+++ src/backend/executor/nodeSetOp.c	(working copy)
@@ -50,6 +50,8 @@
 	TupleTableSlot *resultTupleSlot;
 	PlanState  *outerPlan;
 
+	POSTGRESQL_EXEC_SETOP((uintptr_t)node);
+
 	/*
 	 * get information from the node
 	 */
Index: src/backend/executor/nodeGroup.c
===================================================================
--- src/backend/executor/nodeGroup.c	(revision 30152)
+++ src/backend/executor/nodeGroup.c	(working copy)
@@ -48,6 +48,7 @@
 	econtext = node->ss.ps.ps_ExprContext;
 	numCols = ((Group *) node->ss.ps.plan)->numCols;
 	grpColIdx = ((Group *) node->ss.ps.plan)->grpColIdx;
+	POSTGRESQL_EXEC_GROUP((uintptr_t)node, numCols);
 
 	/*
 	 * The ScanTupleSlot holds the (copied) first tuple of each group.
Index: src/backend/executor/nodeMaterial.c
===================================================================
--- src/backend/executor/nodeMaterial.c	(revision 30152)
+++ src/backend/executor/nodeMaterial.c	(working copy)
@@ -45,6 +45,8 @@
 	bool		eof_tuplestore;
 	TupleTableSlot *slot;
 
+	POSTGRESQL_EXEC_MATERIAL((uintptr_t)node);
+
 	/*
 	 * get state info from node
 	 */
Index: src/backend/executor/nodeAgg.c
===================================================================
--- src/backend/executor/nodeAgg.c	(revision 30152)
+++ src/backend/executor/nodeAgg.c	(working copy)
@@ -806,6 +806,8 @@
 	if (node->agg_done)
 		return NULL;
 
+	POSTGRESQL_EXEC_AGG((uintptr_t)node, ((Agg *) node->ss.ps.plan)->aggstrategy);
+
 	if (((Agg *) node->ss.ps.plan)->aggstrategy == AGG_HASHED)
 	{
 		if (!node->table_filled)
Index: src/backend/executor/nodeHashjoin.c
===================================================================
--- src/backend/executor/nodeHashjoin.c	(revision 30152)
+++ src/backend/executor/nodeHashjoin.c	(working copy)
@@ -58,6 +58,7 @@
 	uint32		hashvalue;
 	int			batchno;
 
+	POSTGRESQL_EXEC_HASHJOIN((uintptr_t)node);
 	/*
 	 * get information from HashJoin node
 	 */
Index: src/backend/executor/nodeLimit.c
===================================================================
--- src/backend/executor/nodeLimit.c	(revision 30152)
+++ src/backend/executor/nodeLimit.c	(working copy)
@@ -41,6 +41,8 @@
 	TupleTableSlot *slot;
 	PlanState  *outerPlan;
 
+	POSTGRESQL_EXEC_LIMIT((uintptr_t)node);
+
 	/*
 	 * get information from the node
 	 */
Index: src/backend/executor/nodeMergejoin.c
===================================================================
--- src/backend/executor/nodeMergejoin.c	(revision 30152)
+++ src/backend/executor/nodeMergejoin.c	(working copy)
@@ -568,6 +568,8 @@
 	bool		doFillOuter;
 	bool		doFillInner;
 
+	POSTGRESQL_EXEC_MERGEJOIN((uintptr_t)node);
+
 	/*
 	 * get information from node
 	 */
Index: src/backend/executor/execScan.c
===================================================================
--- src/backend/executor/execScan.c	(revision 30152)
+++ src/backend/executor/execScan.c	(working copy)
@@ -60,6 +60,8 @@
 	qual = node->ps.qual;
 	projInfo = node->ps.ps_ProjInfo;
 
+	POSTGRESQL_EXEC_SCAN((uintptr_t)node, ((Scan *)node->ps.plan)->scanrelid, (uintptr_t)accessMtd);
+
 	/*
 	 * If we have neither a qual to check nor a projection to do, just skip
 	 * all the overhead and return the raw scan tuple.
Index: src/backend/executor/nodeSort.c
===================================================================
--- src/backend/executor/nodeSort.c	(revision 30152)
+++ src/backend/executor/nodeSort.c	(working copy)
@@ -51,6 +51,9 @@
 
 	estate = node->ss.ps.state;
 	dir = estate->es_direction;
+
+	POSTGRESQL_EXEC_SORT((uintptr_t)node, dir);
+
 	tuplesortstate = (Tuplesortstate *) node->tuplesortstate;
 
 	/*
Index: src/backend/utils/probes.d
===================================================================
--- src/backend/utils/probes.d	(revision 30152)
+++ src/backend/utils/probes.d	(working copy)
@@ -9,6 +9,54 @@
 
 provider postgresql {
 
+probe statement__start(const char *);
+probe mark__dirty(uint32_t);
+probe local__mark__dirty(uint32_t);
+probe slru__readpage__entry(uintptr_t, uint32_t, uint32_t, uint32_t);
+probe slru__readpage__return(uint32_t);
+probe slru__readpage__ro(uintptr_t, uint32_t, uint32_t);
+probe slru__writepage__entry(uintptr_t, uint32_t, uint32_t);
+probe slru__writepage__return();
+probe slru__readpage__physical__entry(uintptr_t, char *, uint32_t, uint32_t);
+probe slru__readpage__physical__return(uint32_t, uint32_t, uint32_t);
+probe slru__writepage__physical__entry(uintptr_t, uint32_t, uint32_t);
+probe slru__writepage__physical__return(uint32_t, uint32_t, uint32_t);
+probe xlog__insert(uint32_t, uint32_t);
+probe xlog__switch();
+probe xlog__checkpoint(uint32_t, uint32_t);
+probe clog__checkpoint__entry();
+probe clog__checkpoint__return();
+probe multixact__checkpoint__entry();
+probe multixact__checkpoint__return();
+probe subtrans__checkpoint__entry();
+probe subtrans__checkpoint__return();
+probe twophase__checkpoint__entry();
+probe twophase__checkpoint__return();
+probe xlog__checkpoint__entry(uint32_t, uint32_t);
+probe xlog__checkpoint__return();
+probe buffers__checkpoint__entry(uint32_t);
+probe buffers__checkpoint__return();
+probe buffer__sync__entry(uint32_t, uint32_t);
+probe buffer__sync__written(uint32_t);
+probe buffer__sync__return(uint32_t, uint32_t, uint32_t);
+probe buffer__flush__entry(uint32_t, uint32_t, uint32_t, uint32_t);
+probe buffer__flush__return(uint32_t, uint32_t, uint32_t, uint32_t);
+probe exec__scan(uintptr_t, uint32_t, uintptr_t);
+probe exec__agg(uintptr_t, uint32_t);
+probe exec__group(uintptr_t, uint32_t);
+probe exec__hash__multi(uintptr_t);
+probe exec__hashjoin(uintptr_t);
+probe exec__limit(uintptr_t);
+probe exec__material(uintptr_t);
+probe exec__mergejoin(uintptr_t);
+probe exec__nestloop(uintptr_t);
+probe exec__setop(uintptr_t);
+probe exec__sort(uintptr_t, uint32_t);
+probe exec__subplan__hash(uintptr_t);
+probe exec__subplan__scan(uintptr_t);
+probe exec__unique(uintptr_t);
+probe autovacuum__start(uint32_t, char *);
+probe autovacuum__relation(uint32_t, char *, char *, char *);
 probe transaction__start(int);
 probe transaction__commit(int);
 probe transaction__abort(int);
Index: src/backend/postmaster/pgstat.c
===================================================================
--- src/backend/postmaster/pgstat.c	(revision 30152)
+++ src/backend/postmaster/pgstat.c	(working copy)
@@ -1891,6 +1891,8 @@
 	TimestampTz start_timestamp;
 	int			len;
 
+	POSTGRESQL_STATEMENT_START((char *)cmd_str);
+
 	if (!pgstat_track_activities || !beentry)
 		return;
 
Index: src/backend/postmaster/autovacuum.c
===================================================================
--- src/backend/postmaster/autovacuum.c	(revision 30152)
+++ src/backend/postmaster/autovacuum.c	(working copy)
@@ -1601,6 +1601,7 @@
 		InitPostgres(NULL, dbid, NULL, &dbname);
 		SetProcessingMode(NormalProcessing);
 		set_ps_display(dbname, false);
+		POSTGRESQL_AUTOVACUUM_START(dbid, dbname);
 		ereport(DEBUG1,
 				(errmsg("autovacuum: processing database \"%s\"", dbname)));
 
@@ -2122,6 +2123,7 @@
 		{
 			/* have at it */
 			MemoryContextSwitchTo(TopTransactionContext);
+			POSTGRESQL_AUTOVACUUM_RELATION(tab->at_relid, datname, nspname, relname);
 			autovacuum_do_vac_analyze(tab->at_relid,
 									  tab->at_dovacuum,
 									  tab->at_doanalyze,
Index: src/backend/access/transam/xact.c
===================================================================
--- src/backend/access/transam/xact.c	(revision 30152)
+++ src/backend/access/transam/xact.c	(working copy)
@@ -1479,7 +1479,7 @@
 	Assert(MyProc->backendId == vxid.backendId);
 	MyProc->lxid = vxid.localTransactionId;
 
-	PG_TRACE1(transaction__start, vxid.localTransactionId);
+	POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);
 
 	/*
 	 * set transaction_timestamp() (a/k/a now()).  We want this to be the same
@@ -1604,7 +1604,7 @@
 	 */
 	latestXid = RecordTransactionCommit();
 
-	PG_TRACE1(transaction__commit, MyProc->lxid);
+	POSTGRESQL_TRANSACTION_COMMIT(MyProc->lxid);
 
 	/*
 	 * Let others know about no transaction in progress by me. Note that this
@@ -1990,7 +1990,7 @@
 	 */
 	latestXid = RecordTransactionAbort(false);
 
-	PG_TRACE1(transaction__abort, MyProc->lxid);
+	POSTGRESQL_TRANSACTION_ABORT(MyProc->lxid);
 
 	/*
 	 * Let others know about no transaction in progress by me. Note that this
Index: src/backend/access/transam/subtrans.c
===================================================================
--- src/backend/access/transam/subtrans.c	(revision 30152)
+++ src/backend/access/transam/subtrans.c	(working copy)
@@ -281,7 +281,9 @@
 	 * it merely to improve the odds that writing of dirty pages is done by
 	 * the checkpoint process and not by backends.
 	 */
+	POSTGRESQL_SUBTRANS_CHECKPOINT_ENTRY();
 	SimpleLruFlush(SubTransCtl, true);
+	POSTGRESQL_SUBTRANS_CHECKPOINT_RETURN();
 }
 
 
Index: src/backend/access/transam/xlog.c
===================================================================
--- src/backend/access/transam/xlog.c	(revision 30152)
+++ src/backend/access/transam/xlog.c	(working copy)
@@ -475,6 +475,8 @@
 	if (info & XLR_INFO_MASK)
 		elog(PANIC, "invalid xlog info mask %02X", info);
 
+	POSTGRESQL_XLOG_INSERT(rmid, info);
+
 	/*
 	 * In bootstrap mode, we don't actually log anything but XLOG resources;
 	 * return a phony record pointer.
@@ -903,6 +905,8 @@
 		XLogwrtRqst FlushRqst;
 		XLogRecPtr	OldSegEnd;
 
+		POSTGRESQL_XLOG_SWITCH();
+
 		LWLockAcquire(WALWriteLock, LW_EXCLUSIVE);
 
 		/*
@@ -5824,6 +5828,8 @@
 	checkPoint.nextXid = ShmemVariableCache->nextXid;
 	LWLockRelease(XidGenLock);
 
+	POSTGRESQL_XLOG_CHECKPOINT_ENTRY(flags, checkPoint.nextXid);
+
 	/* Increase XID epoch if we've wrapped around since last checkpoint */
 	checkPoint.nextXidEpoch = ControlFile->checkPointCopy.nextXidEpoch;
 	if (checkPoint.nextXid < ControlFile->checkPointCopy.nextXid)
@@ -5949,6 +5955,7 @@
 		LogCheckpointEnd();
 
 	LWLockRelease(CheckpointLock);
+	POSTGRESQL_XLOG_CHECKPOINT_RETURN();
 }
 
 /*
Index: src/backend/access/transam/multixact.c
===================================================================
--- src/backend/access/transam/multixact.c	(revision 30152)
+++ src/backend/access/transam/multixact.c	(working copy)
@@ -1526,6 +1526,8 @@
 void
 CheckPointMultiXact(void)
 {
+	POSTGRESQL_MULTIXACT_CHECKPOINT_ENTRY();
+
 	/* Flush dirty MultiXact pages to disk */
 	SimpleLruFlush(MultiXactOffsetCtl, true);
 	SimpleLruFlush(MultiXactMemberCtl, true);
@@ -1540,6 +1542,8 @@
 	 */
 	if (!InRecovery)
 		TruncateMultiXact();
+
+	POSTGRESQL_MULTIXACT_CHECKPOINT_RETURN();
 }
 
 /*
Index: src/backend/access/transam/clog.c
===================================================================
--- src/backend/access/transam/clog.c	(revision 30152)
+++ src/backend/access/transam/clog.c	(working copy)
@@ -323,7 +323,9 @@
 CheckPointCLOG(void)
 {
 	/* Flush dirty CLOG pages to disk */
+        POSTGRESQL_CLOG_CHECKPOINT_ENTRY();
 	SimpleLruFlush(ClogCtl, true);
+        POSTGRESQL_CLOG_CHECKPOINT_RETURN();
 }
 
 
Index: src/backend/access/transam/slru.c
===================================================================
--- src/backend/access/transam/slru.c	(revision 30152)
+++ src/backend/access/transam/slru.c	(working copy)
@@ -372,6 +372,8 @@
 {
 	SlruShared	shared = ctl->shared;
 
+	POSTGRESQL_SLRU_READPAGE_ENTRY((uintptr_t)ctl, pageno, write_ok, xid);
+
 	/* Outer loop handles restart if we must wait for someone else's I/O */
 	for (;;)
 	{
@@ -399,7 +401,7 @@
 			}
 			/* Otherwise, it's ready to use */
 			SlruRecentlyUsed(shared, slotno);
-			return slotno;
+			goto traceout;
 		}
 
 		/* We found no match; assert we selected a freeable slot */
@@ -446,6 +448,9 @@
 			SlruReportIOError(ctl, pageno, xid);
 
 		SlruRecentlyUsed(shared, slotno);
+
+		traceout:
+		POSTGRESQL_SLRU_READPAGE_RETURN(slotno);
 		return slotno;
 	}
 }
@@ -470,6 +475,8 @@
 	SlruShared	shared = ctl->shared;
 	int			slotno;
 
+	POSTGRESQL_SLRU_READPAGE_RO((uintptr_t)ctl, pageno, xid);
+
 	/* Try to find the page while holding only shared lock */
 	LWLockAcquire(shared->ControlLock, LW_SHARED);
 
@@ -511,6 +518,8 @@
 	int			pageno = shared->page_number[slotno];
 	bool		ok;
 
+	POSTGRESQL_SLRU_WRITEPAGE_ENTRY((uintptr_t)ctl, pageno, slotno);
+
 	/* If a write is in progress, wait for it to finish */
 	while (shared->page_status[slotno] == SLRU_PAGE_WRITE_IN_PROGRESS &&
 		   shared->page_number[slotno] == pageno)
@@ -525,7 +534,7 @@
 	if (!shared->page_dirty[slotno] ||
 		shared->page_status[slotno] != SLRU_PAGE_VALID ||
 		shared->page_number[slotno] != pageno)
-		return;
+		goto traceout;
 
 	/*
 	 * Mark the slot write-busy, and clear the dirtybit.  After this point, a
@@ -569,6 +578,9 @@
 	/* Now it's okay to ereport if we failed */
 	if (!ok)
 		SlruReportIOError(ctl, pageno, InvalidTransactionId);
+
+	traceout:
+	POSTGRESQL_SLRU_WRITEPAGE_RETURN();
 }
 
 /*
@@ -590,9 +602,12 @@
 	int			offset = rpageno * BLCKSZ;
 	char		path[MAXPGPATH];
 	int			fd;
+	bool		retval = false;
 
 	SlruFileName(ctl, path, segno);
 
+	POSTGRESQL_SLRU_READPAGE_PHYSICAL_ENTRY((uintptr_t)ctl, path, pageno, slotno);
+
 	/*
 	 * In a crash-and-restart situation, it's possible for us to receive
 	 * commands to set the commit status of transactions whose bits are in
@@ -607,14 +622,16 @@
 		{
 			slru_errcause = SLRU_OPEN_FAILED;
 			slru_errno = errno;
-			return false;
+			retval = false;
+			goto traceout;
 		}
 
 		ereport(LOG,
 				(errmsg("file \"%s\" doesn't exist, reading as zeroes",
 						path)));
 		MemSet(shared->page_buffer[slotno], 0, BLCKSZ);
-		return true;
+		retval = true;
+		goto traceout;
 	}
 
 	if (lseek(fd, (off_t) offset, SEEK_SET) < 0)
@@ -622,7 +639,8 @@
 		slru_errcause = SLRU_SEEK_FAILED;
 		slru_errno = errno;
 		close(fd);
-		return false;
+		retval = false;
+		goto traceout;
 	}
 
 	errno = 0;
@@ -631,17 +649,23 @@
 		slru_errcause = SLRU_READ_FAILED;
 		slru_errno = errno;
 		close(fd);
-		return false;
+		retval = false;
+		goto traceout;
 	}
 
 	if (close(fd))
 	{
 		slru_errcause = SLRU_CLOSE_FAILED;
 		slru_errno = errno;
-		return false;
+		retval = false;
+		goto traceout;
 	}
 
-	return true;
+	retval = true;
+
+	traceout:
+	POSTGRESQL_SLRU_READPAGE_PHYSICAL_RETURN(retval, slru_errcause, slru_errno);
+	return retval;
 }
 
 /*
@@ -667,7 +691,10 @@
 	int			offset = rpageno * BLCKSZ;
 	char		path[MAXPGPATH];
 	int			fd = -1;
+	bool		retval = false;
 
+	POSTGRESQL_SLRU_WRITEPAGE_PHYSICAL_ENTRY((uintptr_t)ctl, pageno, slotno);
+
 	/*
 	 * Honor the write-WAL-before-data rule, if appropriate, so that we do not
 	 * write out data before associated WAL records.  This is the same action
@@ -753,7 +780,8 @@
 		{
 			slru_errcause = SLRU_OPEN_FAILED;
 			slru_errno = errno;
-			return false;
+			retval = false;
+			goto traceout;
 		}
 
 		if (fdata)
@@ -781,7 +809,8 @@
 		slru_errno = errno;
 		if (!fdata)
 			close(fd);
-		return false;
+		retval = false;
+		goto traceout;
 	}
 
 	errno = 0;
@@ -794,7 +823,8 @@
 		slru_errno = errno;
 		if (!fdata)
 			close(fd);
-		return false;
+		retval = false;
+		goto traceout;
 	}
 
 	/*
@@ -808,18 +838,23 @@
 			slru_errcause = SLRU_FSYNC_FAILED;
 			slru_errno = errno;
 			close(fd);
-			return false;
+			retval = false;
+			goto traceout;
 		}
 
 		if (close(fd))
 		{
 			slru_errcause = SLRU_CLOSE_FAILED;
 			slru_errno = errno;
-			return false;
+			retval = false;
+			goto traceout;
 		}
 	}
 
-	return true;
+	retval = true;
+	traceout:
+	POSTGRESQL_SLRU_WRITEPAGE_PHYSICAL_RETURN(retval, slru_errcause, slru_errno);
+	return retval;
 }
 
 /*
Index: src/backend/access/transam/twophase.c
===================================================================
--- src/backend/access/transam/twophase.c	(revision 30152)
+++ src/backend/access/transam/twophase.c	(working copy)
@@ -1376,6 +1376,9 @@
 	 */
 	if (max_prepared_xacts <= 0)
 		return;					/* nothing to do */
+
+	POSTGRESQL_TWOPHASE_CHECKPOINT_ENTRY();
+
 	xids = (TransactionId *) palloc(max_prepared_xacts * sizeof(TransactionId));
 	nxids = 0;
 
@@ -1433,6 +1436,8 @@
 	}
 
 	pfree(xids);
+
+	POSTGRESQL_TWOPHASE_CHECKPOINT_RETURN();
 }
 
 /*
Index: src/backend/storage/lmgr/lock.c
===================================================================
--- src/backend/storage/lmgr/lock.c	(revision 30152)
+++ src/backend/storage/lmgr/lock.c	(working copy)
@@ -787,11 +787,11 @@
 		 * Sleep till someone wakes me up.
 		 */
 
-		PG_TRACE2(lock__startwait, locktag->locktag_field2, lockmode);
+		POSTGRESQL_LOCK_STARTWAIT(locktag->locktag_field2, lockmode);
 
 		WaitOnLock(locallock, owner);
 
-		PG_TRACE2(lock__endwait, locktag->locktag_field2, lockmode);
+		POSTGRESQL_LOCK_ENDWAIT(locktag->locktag_field2, lockmode);
 
 		/*
 		 * NOTE: do not do any material change of state between here and
Index: src/backend/storage/lmgr/lwlock.c
===================================================================
--- src/backend/storage/lmgr/lwlock.c	(revision 30152)
+++ src/backend/storage/lmgr/lwlock.c	(working copy)
@@ -447,7 +447,7 @@
 		block_counts[lockid]++;
 #endif
 
-		PG_TRACE2(lwlock__startwait, lockid, mode);
+		POSTGRESQL_LWLOCK_STARTWAIT(lockid, mode);
 
 		for (;;)
 		{
@@ -458,7 +458,7 @@
 			extraWaits++;
 		}
 
-		PG_TRACE2(lwlock__endwait, lockid, mode);
+		POSTGRESQL_LWLOCK_ENDWAIT(lockid, mode);
 
 		LOG_LWDEBUG("LWLockAcquire", lockid, "awakened");
 
@@ -469,7 +469,7 @@
 	/* We are done updating shared state of the lock itself. */
 	SpinLockRelease(&lock->mutex);
 
-	PG_TRACE2(lwlock__acquire, lockid, mode);
+	POSTGRESQL_LWLOCK_ACQUIRE(lockid, mode);
 
 	/* Add lock to list of locks held by this backend */
 	held_lwlocks[num_held_lwlocks++] = lockid;
@@ -540,13 +540,13 @@
 		/* Failed to get lock, so release interrupt holdoff */
 		RESUME_INTERRUPTS();
 		LOG_LWDEBUG("LWLockConditionalAcquire", lockid, "failed");
-		PG_TRACE2(lwlock__condacquire__fail, lockid, mode);
+		POSTGRESQL_LWLOCK_CONDACQUIRE_FAIL(lockid, mode);
 	}
 	else
 	{
 		/* Add lock to list of locks held by this backend */
 		held_lwlocks[num_held_lwlocks++] = lockid;
-		PG_TRACE2(lwlock__condacquire, lockid, mode);
+		POSTGRESQL_LWLOCK_CONDACQUIRE(lockid, mode);
 	}
 
 	return !mustwait;
@@ -631,7 +631,7 @@
 	/* We are done updating shared state of the lock itself. */
 	SpinLockRelease(&lock->mutex);
 
-	PG_TRACE1(lwlock__release, lockid);
+	POSTGRESQL_LWLOCK_RELEASE(lockid);
 
 	/*
 	 * Awaken any waiters I removed from the queue.
Index: src/backend/storage/buffer/bufmgr.c
===================================================================
--- src/backend/storage/buffer/bufmgr.c	(revision 30152)
+++ src/backend/storage/buffer/bufmgr.c	(working copy)
@@ -809,6 +809,7 @@
 	bufHdr->flags |= (BM_DIRTY | BM_JUST_DIRTIED);
 
 	UnlockBufHdr(bufHdr);
+	POSTGRESQL_MARK_DIRTY(buffer);
 }
 
 /*
@@ -1050,6 +1051,7 @@
 	 * Note that we don't read the buffer alloc count here --- that should be
 	 * left untouched till the next BgBufferSync() call.
 	 */
+	POSTGRESQL_BUFFER_SYNC_ENTRY(NBuffers, num_to_write);
 	buf_id = StrategySyncStart(NULL, NULL);
 	num_to_scan = NBuffers;
 	num_written = 0;
@@ -1073,6 +1075,7 @@
 		{
 			if (SyncOneBuffer(buf_id, false) & BUF_WRITTEN)
 			{
+				POSTGRESQL_BUFFER_SYNC_WRITTEN(buf_id);
 				BgWriterStats.m_buf_written_checkpoints++;
 				num_written++;
 
@@ -1107,6 +1110,7 @@
 	 * Update checkpoint statistics. As noted above, this doesn't include
 	 * buffers written by other backends or bgwriter scan.
 	 */
+	POSTGRESQL_BUFFER_SYNC_RETURN(NBuffers, num_written, num_to_write);
 	CheckpointStats.ckpt_bufs_written += num_written;
 }
 
@@ -1609,11 +1613,13 @@
 void
 CheckPointBuffers(int flags)
 {
+	POSTGRESQL_BUFFERS_CHECKPOINT_ENTRY(flags);
 	CheckpointStats.ckpt_write_t = GetCurrentTimestamp();
 	BufferSync(flags);
 	CheckpointStats.ckpt_sync_t = GetCurrentTimestamp();
 	smgrsync();
 	CheckpointStats.ckpt_sync_end_t = GetCurrentTimestamp();
+	POSTGRESQL_BUFFERS_CHECKPOINT_RETURN();
 }
 
 
@@ -1705,6 +1711,8 @@
 	if (!StartBufferIO(buf, false))
 		return;
 
+	POSTGRESQL_BUFFER_FLUSH_ENTRY(buf->tag.rnode.dbNode, buf->tag.rnode.spcNode, buf->tag.rnode.relNode, buf->tag.blockNum);
+
 	/* Setup error traceback support for ereport() */
 	errcontext.callback = buffer_write_error_callback;
 	errcontext.arg = (void *) buf;
@@ -1741,6 +1749,8 @@
 
 	BufferFlushCount++;
 
+	POSTGRESQL_BUFFER_FLUSH_RETURN(buf->tag.rnode.dbNode, buf->tag.rnode.spcNode, buf->tag.rnode.relNode, buf->tag.blockNum);
+
 	/*
 	 * Mark the buffer as clean (unless BM_JUST_DIRTIED has become set) and
 	 * end the io_in_progress state.
Index: src/backend/storage/buffer/localbuf.c
===================================================================
--- src/backend/storage/buffer/localbuf.c	(revision 30152)
+++ src/backend/storage/buffer/localbuf.c	(working copy)
@@ -236,6 +236,7 @@
 
 	bufHdr = &LocalBufferDescriptors[bufid];
 	bufHdr->flags |= BM_DIRTY;
+	POSTGRESQL_LOCAL_MARK_DIRTY(buffer);
 }
 
 /*
Index: src/include/pg_trace.h
===================================================================
--- src/include/pg_trace.h	Tue Jan  1 21:42:06 2008
+++ src/include/pg_trace.h	Mon Apr  7 13:31:41 2008
@@ -1,54 +1,501 @@
-/* ----------
- *	pg_trace.h
- *
- *	Definitions for the PostgreSQL tracing framework
- *
- *	Copyright (c) 2006-2008, PostgreSQL Global Development Group
- *
- *	$PostgreSQL: pgsql/src/include/pg_trace.h,v 1.3 2008/01/02 02:42:06 momjian Exp $
- * ----------
+/*
+ * Generated by dtrace(1M).
  */
 
-#ifndef PG_TRACE_H
-#define PG_TRACE_H
+#ifndef	_PG_TRACE_H_TMP
+#define	_PG_TRACE_H_TMP
 
+#include <unistd.h>
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
 #ifdef ENABLE_DTRACE
 
-#include <sys/sdt.h>
+#define	POSTGRESQL_AUTOVACUUM_RELATION(arg0, arg1, arg2, arg3) \
+	__dtrace_postgresql___autovacuum__relation(arg0, arg1, arg2, arg3)
+#define	POSTGRESQL_AUTOVACUUM_RELATION_ENABLED() \
+	__dtraceenabled_postgresql___autovacuum__relation()
+#define	POSTGRESQL_AUTOVACUUM_START(arg0, arg1) \
+	__dtrace_postgresql___autovacuum__start(arg0, arg1)
+#define	POSTGRESQL_AUTOVACUUM_START_ENABLED() \
+	__dtraceenabled_postgresql___autovacuum__start()
+#define	POSTGRESQL_BUFFER_FLUSH_ENTRY(arg0, arg1, arg2, arg3) \
+	__dtrace_postgresql___buffer__flush__entry(arg0, arg1, arg2, arg3)
+#define	POSTGRESQL_BUFFER_FLUSH_ENTRY_ENABLED() \
+	__dtraceenabled_postgresql___buffer__flush__entry()
+#define	POSTGRESQL_BUFFER_FLUSH_RETURN(arg0, arg1, arg2, arg3) \
+	__dtrace_postgresql___buffer__flush__return(arg0, arg1, arg2, arg3)
+#define	POSTGRESQL_BUFFER_FLUSH_RETURN_ENABLED() \
+	__dtraceenabled_postgresql___buffer__flush__return()
+#define	POSTGRESQL_BUFFER_SYNC_ENTRY(arg0, arg1) \
+	__dtrace_postgresql___buffer__sync__entry(arg0, arg1)
+#define	POSTGRESQL_BUFFER_SYNC_ENTRY_ENABLED() \
+	__dtraceenabled_postgresql___buffer__sync__entry()
+#define	POSTGRESQL_BUFFER_SYNC_RETURN(arg0, arg1, arg2) \
+	__dtrace_postgresql___buffer__sync__return(arg0, arg1, arg2)
+#define	POSTGRESQL_BUFFER_SYNC_RETURN_ENABLED() \
+	__dtraceenabled_postgresql___buffer__sync__return()
+#define	POSTGRESQL_BUFFER_SYNC_WRITTEN(arg0) \
+	__dtrace_postgresql___buffer__sync__written(arg0)
+#define	POSTGRESQL_BUFFER_SYNC_WRITTEN_ENABLED() \
+	__dtraceenabled_postgresql___buffer__sync__written()
+#define	POSTGRESQL_BUFFERS_CHECKPOINT_ENTRY(arg0) \
+	__dtrace_postgresql___buffers__checkpoint__entry(arg0)
+#define	POSTGRESQL_BUFFERS_CHECKPOINT_ENTRY_ENABLED() \
+	__dtraceenabled_postgresql___buffers__checkpoint__entry()
+#define	POSTGRESQL_BUFFERS_CHECKPOINT_RETURN() \
+	__dtrace_postgresql___buffers__checkpoint__return()
+#define	POSTGRESQL_BUFFERS_CHECKPOINT_RETURN_ENABLED() \
+	__dtraceenabled_postgresql___buffers__checkpoint__return()
+#define	POSTGRESQL_CLOG_CHECKPOINT_ENTRY() \
+	__dtrace_postgresql___clog__checkpoint__entry()
+#define	POSTGRESQL_CLOG_CHECKPOINT_ENTRY_ENABLED() \
+	__dtraceenabled_postgresql___clog__checkpoint__entry()
+#define	POSTGRESQL_CLOG_CHECKPOINT_RETURN() \
+	__dtrace_postgresql___clog__checkpoint__return()
+#define	POSTGRESQL_CLOG_CHECKPOINT_RETURN_ENABLED() \
+	__dtraceenabled_postgresql___clog__checkpoint__return()
+#define	POSTGRESQL_EXEC_AGG(arg0, arg1) \
+	__dtrace_postgresql___exec__agg(arg0, arg1)
+#define	POSTGRESQL_EXEC_AGG_ENABLED() \
+	__dtraceenabled_postgresql___exec__agg()
+#define	POSTGRESQL_EXEC_GROUP(arg0, arg1) \
+	__dtrace_postgresql___exec__group(arg0, arg1)
+#define	POSTGRESQL_EXEC_GROUP_ENABLED() \
+	__dtraceenabled_postgresql___exec__group()
+#define	POSTGRESQL_EXEC_HASH_MULTI(arg0) \
+	__dtrace_postgresql___exec__hash__multi(arg0)
+#define	POSTGRESQL_EXEC_HASH_MULTI_ENABLED() \
+	__dtraceenabled_postgresql___exec__hash__multi()
+#define	POSTGRESQL_EXEC_HASHJOIN(arg0) \
+	__dtrace_postgresql___exec__hashjoin(arg0)
+#define	POSTGRESQL_EXEC_HASHJOIN_ENABLED() \
+	__dtraceenabled_postgresql___exec__hashjoin()
+#define	POSTGRESQL_EXEC_LIMIT(arg0) \
+	__dtrace_postgresql___exec__limit(arg0)
+#define	POSTGRESQL_EXEC_LIMIT_ENABLED() \
+	__dtraceenabled_postgresql___exec__limit()
+#define	POSTGRESQL_EXEC_MATERIAL(arg0) \
+	__dtrace_postgresql___exec__material(arg0)
+#define	POSTGRESQL_EXEC_MATERIAL_ENABLED() \
+	__dtraceenabled_postgresql___exec__material()
+#define	POSTGRESQL_EXEC_MERGEJOIN(arg0) \
+	__dtrace_postgresql___exec__mergejoin(arg0)
+#define	POSTGRESQL_EXEC_MERGEJOIN_ENABLED() \
+	__dtraceenabled_postgresql___exec__mergejoin()
+#define	POSTGRESQL_EXEC_NESTLOOP(arg0) \
+	__dtrace_postgresql___exec__nestloop(arg0)
+#define	POSTGRESQL_EXEC_NESTLOOP_ENABLED() \
+	__dtraceenabled_postgresql___exec__nestloop()
+#define	POSTGRESQL_EXEC_SCAN(arg0, arg1, arg2) \
+	__dtrace_postgresql___exec__scan(arg0, arg1, arg2)
+#define	POSTGRESQL_EXEC_SCAN_ENABLED() \
+	__dtraceenabled_postgresql___exec__scan()
+#define	POSTGRESQL_EXEC_SETOP(arg0) \
+	__dtrace_postgresql___exec__setop(arg0)
+#define	POSTGRESQL_EXEC_SETOP_ENABLED() \
+	__dtraceenabled_postgresql___exec__setop()
+#define	POSTGRESQL_EXEC_SORT(arg0, arg1) \
+	__dtrace_postgresql___exec__sort(arg0, arg1)
+#define	POSTGRESQL_EXEC_SORT_ENABLED() \
+	__dtraceenabled_postgresql___exec__sort()
+#define	POSTGRESQL_EXEC_SUBPLAN_HASH(arg0) \
+	__dtrace_postgresql___exec__subplan__hash(arg0)
+#define	POSTGRESQL_EXEC_SUBPLAN_HASH_ENABLED() \
+	__dtraceenabled_postgresql___exec__subplan__hash()
+#define	POSTGRESQL_EXEC_SUBPLAN_SCAN(arg0) \
+	__dtrace_postgresql___exec__subplan__scan(arg0)
+#define	POSTGRESQL_EXEC_SUBPLAN_SCAN_ENABLED() \
+	__dtraceenabled_postgresql___exec__subplan__scan()
+#define	POSTGRESQL_EXEC_UNIQUE(arg0) \
+	__dtrace_postgresql___exec__unique(arg0)
+#define	POSTGRESQL_EXEC_UNIQUE_ENABLED() \
+	__dtraceenabled_postgresql___exec__unique()
+#define	POSTGRESQL_LOCAL_MARK_DIRTY(arg0) \
+	__dtrace_postgresql___local__mark__dirty(arg0)
+#define	POSTGRESQL_LOCAL_MARK_DIRTY_ENABLED() \
+	__dtraceenabled_postgresql___local__mark__dirty()
+#define	POSTGRESQL_LOCK_ENDWAIT(arg0, arg1) \
+	__dtrace_postgresql___lock__endwait(arg0, arg1)
+#define	POSTGRESQL_LOCK_ENDWAIT_ENABLED() \
+	__dtraceenabled_postgresql___lock__endwait()
+#define	POSTGRESQL_LOCK_STARTWAIT(arg0, arg1) \
+	__dtrace_postgresql___lock__startwait(arg0, arg1)
+#define	POSTGRESQL_LOCK_STARTWAIT_ENABLED() \
+	__dtraceenabled_postgresql___lock__startwait()
+#define	POSTGRESQL_LWLOCK_ACQUIRE(arg0, arg1) \
+	__dtrace_postgresql___lwlock__acquire(arg0, arg1)
+#define	POSTGRESQL_LWLOCK_ACQUIRE_ENABLED() \
+	__dtraceenabled_postgresql___lwlock__acquire()
+#define	POSTGRESQL_LWLOCK_CONDACQUIRE(arg0, arg1) \
+	__dtrace_postgresql___lwlock__condacquire(arg0, arg1)
+#define	POSTGRESQL_LWLOCK_CONDACQUIRE_ENABLED() \
+	__dtraceenabled_postgresql___lwlock__condacquire()
+#define	POSTGRESQL_LWLOCK_CONDACQUIRE_FAIL(arg0, arg1) \
+	__dtrace_postgresql___lwlock__condacquire__fail(arg0, arg1)
+#define	POSTGRESQL_LWLOCK_CONDACQUIRE_FAIL_ENABLED() \
+	__dtraceenabled_postgresql___lwlock__condacquire__fail()
+#define	POSTGRESQL_LWLOCK_ENDWAIT(arg0, arg1) \
+	__dtrace_postgresql___lwlock__endwait(arg0, arg1)
+#define	POSTGRESQL_LWLOCK_ENDWAIT_ENABLED() \
+	__dtraceenabled_postgresql___lwlock__endwait()
+#define	POSTGRESQL_LWLOCK_RELEASE(arg0) \
+	__dtrace_postgresql___lwlock__release(arg0)
+#define	POSTGRESQL_LWLOCK_RELEASE_ENABLED() \
+	__dtraceenabled_postgresql___lwlock__release()
+#define	POSTGRESQL_LWLOCK_STARTWAIT(arg0, arg1) \
+	__dtrace_postgresql___lwlock__startwait(arg0, arg1)
+#define	POSTGRESQL_LWLOCK_STARTWAIT_ENABLED() \
+	__dtraceenabled_postgresql___lwlock__startwait()
+#define	POSTGRESQL_MARK_DIRTY(arg0) \
+	__dtrace_postgresql___mark__dirty(arg0)
+#define	POSTGRESQL_MARK_DIRTY_ENABLED() \
+	__dtraceenabled_postgresql___mark__dirty()
+#define	POSTGRESQL_MULTIXACT_CHECKPOINT_ENTRY() \
+	__dtrace_postgresql___multixact__checkpoint__entry()
+#define	POSTGRESQL_MULTIXACT_CHECKPOINT_ENTRY_ENABLED() \
+	__dtraceenabled_postgresql___multixact__checkpoint__entry()
+#define	POSTGRESQL_MULTIXACT_CHECKPOINT_RETURN() \
+	__dtrace_postgresql___multixact__checkpoint__return()
+#define	POSTGRESQL_MULTIXACT_CHECKPOINT_RETURN_ENABLED() \
+	__dtraceenabled_postgresql___multixact__checkpoint__return()
+#define	POSTGRESQL_SLRU_READPAGE_ENTRY(arg0, arg1, arg2, arg3) \
+	__dtrace_postgresql___slru__readpage__entry(arg0, arg1, arg2, arg3)
+#define	POSTGRESQL_SLRU_READPAGE_ENTRY_ENABLED() \
+	__dtraceenabled_postgresql___slru__readpage__entry()
+#define	POSTGRESQL_SLRU_READPAGE_PHYSICAL_ENTRY(arg0, arg1, arg2, arg3) \
+	__dtrace_postgresql___slru__readpage__physical__entry(arg0, arg1, arg2, arg3)
+#define	POSTGRESQL_SLRU_READPAGE_PHYSICAL_ENTRY_ENABLED() \
+	__dtraceenabled_postgresql___slru__readpage__physical__entry()
+#define	POSTGRESQL_SLRU_READPAGE_PHYSICAL_RETURN(arg0, arg1, arg2) \
+	__dtrace_postgresql___slru__readpage__physical__return(arg0, arg1, arg2)
+#define	POSTGRESQL_SLRU_READPAGE_PHYSICAL_RETURN_ENABLED() \
+	__dtraceenabled_postgresql___slru__readpage__physical__return()
+#define	POSTGRESQL_SLRU_READPAGE_RETURN(arg0) \
+	__dtrace_postgresql___slru__readpage__return(arg0)
+#define	POSTGRESQL_SLRU_READPAGE_RETURN_ENABLED() \
+	__dtraceenabled_postgresql___slru__readpage__return()
+#define	POSTGRESQL_SLRU_READPAGE_RO(arg0, arg1, arg2) \
+	__dtrace_postgresql___slru__readpage__ro(arg0, arg1, arg2)
+#define	POSTGRESQL_SLRU_READPAGE_RO_ENABLED() \
+	__dtraceenabled_postgresql___slru__readpage__ro()
+#define	POSTGRESQL_SLRU_WRITEPAGE_ENTRY(arg0, arg1, arg2) \
+	__dtrace_postgresql___slru__writepage__entry(arg0, arg1, arg2)
+#define	POSTGRESQL_SLRU_WRITEPAGE_ENTRY_ENABLED() \
+	__dtraceenabled_postgresql___slru__writepage__entry()
+#define	POSTGRESQL_SLRU_WRITEPAGE_PHYSICAL_ENTRY(arg0, arg1, arg2) \
+	__dtrace_postgresql___slru__writepage__physical__entry(arg0, arg1, arg2)
+#define	POSTGRESQL_SLRU_WRITEPAGE_PHYSICAL_ENTRY_ENABLED() \
+	__dtraceenabled_postgresql___slru__writepage__physical__entry()
+#define	POSTGRESQL_SLRU_WRITEPAGE_PHYSICAL_RETURN(arg0, arg1, arg2) \
+	__dtrace_postgresql___slru__writepage__physical__return(arg0, arg1, arg2)
+#define	POSTGRESQL_SLRU_WRITEPAGE_PHYSICAL_RETURN_ENABLED() \
+	__dtraceenabled_postgresql___slru__writepage__physical__return()
+#define	POSTGRESQL_SLRU_WRITEPAGE_RETURN() \
+	__dtrace_postgresql___slru__writepage__return()
+#define	POSTGRESQL_SLRU_WRITEPAGE_RETURN_ENABLED() \
+	__dtraceenabled_postgresql___slru__writepage__return()
+#define	POSTGRESQL_STATEMENT_START(arg0) \
+	__dtrace_postgresql___statement__start(arg0)
+#define	POSTGRESQL_STATEMENT_START_ENABLED() \
+	__dtraceenabled_postgresql___statement__start()
+#define	POSTGRESQL_SUBTRANS_CHECKPOINT_ENTRY() \
+	__dtrace_postgresql___subtrans__checkpoint__entry()
+#define	POSTGRESQL_SUBTRANS_CHECKPOINT_ENTRY_ENABLED() \
+	__dtraceenabled_postgresql___subtrans__checkpoint__entry()
+#define	POSTGRESQL_SUBTRANS_CHECKPOINT_RETURN() \
+	__dtrace_postgresql___subtrans__checkpoint__return()
+#define	POSTGRESQL_SUBTRANS_CHECKPOINT_RETURN_ENABLED() \
+	__dtraceenabled_postgresql___subtrans__checkpoint__return()
+#define	POSTGRESQL_TRANSACTION_ABORT(arg0) \
+	__dtrace_postgresql___transaction__abort(arg0)
+#define	POSTGRESQL_TRANSACTION_ABORT_ENABLED() \
+	__dtraceenabled_postgresql___transaction__abort()
+#define	POSTGRESQL_TRANSACTION_COMMIT(arg0) \
+	__dtrace_postgresql___transaction__commit(arg0)
+#define	POSTGRESQL_TRANSACTION_COMMIT_ENABLED() \
+	__dtraceenabled_postgresql___transaction__commit()
+#define	POSTGRESQL_TRANSACTION_START(arg0) \
+	__dtrace_postgresql___transaction__start(arg0)
+#define	POSTGRESQL_TRANSACTION_START_ENABLED() \
+	__dtraceenabled_postgresql___transaction__start()
+#define	POSTGRESQL_TWOPHASE_CHECKPOINT_ENTRY() \
+	__dtrace_postgresql___twophase__checkpoint__entry()
+#define	POSTGRESQL_TWOPHASE_CHECKPOINT_ENTRY_ENABLED() \
+	__dtraceenabled_postgresql___twophase__checkpoint__entry()
+#define	POSTGRESQL_TWOPHASE_CHECKPOINT_RETURN() \
+	__dtrace_postgresql___twophase__checkpoint__return()
+#define	POSTGRESQL_TWOPHASE_CHECKPOINT_RETURN_ENABLED() \
+	__dtraceenabled_postgresql___twophase__checkpoint__return()
+#define	POSTGRESQL_XLOG_CHECKPOINT(arg0, arg1) \
+	__dtrace_postgresql___xlog__checkpoint(arg0, arg1)
+#define	POSTGRESQL_XLOG_CHECKPOINT_ENABLED() \
+	__dtraceenabled_postgresql___xlog__checkpoint()
+#define	POSTGRESQL_XLOG_CHECKPOINT_ENTRY(arg0, arg1) \
+	__dtrace_postgresql___xlog__checkpoint__entry(arg0, arg1)
+#define	POSTGRESQL_XLOG_CHECKPOINT_ENTRY_ENABLED() \
+	__dtraceenabled_postgresql___xlog__checkpoint__entry()
+#define	POSTGRESQL_XLOG_CHECKPOINT_RETURN() \
+	__dtrace_postgresql___xlog__checkpoint__return()
+#define	POSTGRESQL_XLOG_CHECKPOINT_RETURN_ENABLED() \
+	__dtraceenabled_postgresql___xlog__checkpoint__return()
+#define	POSTGRESQL_XLOG_INSERT(arg0, arg1) \
+	__dtrace_postgresql___xlog__insert(arg0, arg1)
+#define	POSTGRESQL_XLOG_INSERT_ENABLED() \
+	__dtraceenabled_postgresql___xlog__insert()
+#define	POSTGRESQL_XLOG_SWITCH() \
+	__dtrace_postgresql___xlog__switch()
+#define	POSTGRESQL_XLOG_SWITCH_ENABLED() \
+	__dtraceenabled_postgresql___xlog__switch()
 
-/*
- * The PG_TRACE macros are mapped to the appropriate macros used by DTrace.
- *
- * Only one DTrace provider called "postgresql" will be used for PostgreSQL,
- * so the name is hard-coded here to avoid having to specify it in the
- * source code.
- */
 
-#define PG_TRACE(name) \
-	DTRACE_PROBE(postgresql, name)
-#define PG_TRACE1(name, arg1) \
-	DTRACE_PROBE1(postgresql, name, arg1)
-#define PG_TRACE2(name, arg1, arg2) \
-	DTRACE_PROBE2(postgresql, name, arg1, arg2)
-#define PG_TRACE3(name, arg1, arg2, arg3) \
-	DTRACE_PROBE3(postgresql, name, arg1, arg2, arg3)
-#define PG_TRACE4(name, arg1, arg2, arg3, arg4) \
-	DTRACE_PROBE4(postgresql, name, arg1, arg2, arg3, arg4)
-#define PG_TRACE5(name, arg1, arg2, arg3, arg4, arg5) \
-	DTRACE_PROBE5(postgresql, name, arg1, arg2, arg3, arg4, arg5)
-#else							/* not ENABLE_DTRACE */
+extern void __dtrace_postgresql___autovacuum__relation(uint32_t, char *, char *, char *);
+extern int __dtraceenabled_postgresql___autovacuum__relation(void);
+extern void __dtrace_postgresql___autovacuum__start(uint32_t, char *);
+extern int __dtraceenabled_postgresql___autovacuum__start(void);
+extern void __dtrace_postgresql___buffer__flush__entry(uint32_t, uint32_t, uint32_t, uint32_t);
+extern int __dtraceenabled_postgresql___buffer__flush__entry(void);
+extern void __dtrace_postgresql___buffer__flush__return(uint32_t, uint32_t, uint32_t, uint32_t);
+extern int __dtraceenabled_postgresql___buffer__flush__return(void);
+extern void __dtrace_postgresql___buffer__sync__entry(uint32_t, uint32_t);
+extern int __dtraceenabled_postgresql___buffer__sync__entry(void);
+extern void __dtrace_postgresql___buffer__sync__return(uint32_t, uint32_t, uint32_t);
+extern int __dtraceenabled_postgresql___buffer__sync__return(void);
+extern void __dtrace_postgresql___buffer__sync__written(uint32_t);
+extern int __dtraceenabled_postgresql___buffer__sync__written(void);
+extern void __dtrace_postgresql___buffers__checkpoint__entry(uint32_t);
+extern int __dtraceenabled_postgresql___buffers__checkpoint__entry(void);
+extern void __dtrace_postgresql___buffers__checkpoint__return(void);
+extern int __dtraceenabled_postgresql___buffers__checkpoint__return(void);
+extern void __dtrace_postgresql___clog__checkpoint__entry(void);
+extern int __dtraceenabled_postgresql___clog__checkpoint__entry(void);
+extern void __dtrace_postgresql___clog__checkpoint__return(void);
+extern int __dtraceenabled_postgresql___clog__checkpoint__return(void);
+extern void __dtrace_postgresql___exec__agg(uintptr_t, uint32_t);
+extern int __dtraceenabled_postgresql___exec__agg(void);
+extern void __dtrace_postgresql___exec__group(uintptr_t, uint32_t);
+extern int __dtraceenabled_postgresql___exec__group(void);
+extern void __dtrace_postgresql___exec__hash__multi(uintptr_t);
+extern int __dtraceenabled_postgresql___exec__hash__multi(void);
+extern void __dtrace_postgresql___exec__hashjoin(uintptr_t);
+extern int __dtraceenabled_postgresql___exec__hashjoin(void);
+extern void __dtrace_postgresql___exec__limit(uintptr_t);
+extern int __dtraceenabled_postgresql___exec__limit(void);
+extern void __dtrace_postgresql___exec__material(uintptr_t);
+extern int __dtraceenabled_postgresql___exec__material(void);
+extern void __dtrace_postgresql___exec__mergejoin(uintptr_t);
+extern int __dtraceenabled_postgresql___exec__mergejoin(void);
+extern void __dtrace_postgresql___exec__nestloop(uintptr_t);
+extern int __dtraceenabled_postgresql___exec__nestloop(void);
+extern void __dtrace_postgresql___exec__scan(uintptr_t, uint32_t, uintptr_t);
+extern int __dtraceenabled_postgresql___exec__scan(void);
+extern void __dtrace_postgresql___exec__setop(uintptr_t);
+extern int __dtraceenabled_postgresql___exec__setop(void);
+extern void __dtrace_postgresql___exec__sort(uintptr_t, uint32_t);
+extern int __dtraceenabled_postgresql___exec__sort(void);
+extern void __dtrace_postgresql___exec__subplan__hash(uintptr_t);
+extern int __dtraceenabled_postgresql___exec__subplan__hash(void);
+extern void __dtrace_postgresql___exec__subplan__scan(uintptr_t);
+extern int __dtraceenabled_postgresql___exec__subplan__scan(void);
+extern void __dtrace_postgresql___exec__unique(uintptr_t);
+extern int __dtraceenabled_postgresql___exec__unique(void);
+extern void __dtrace_postgresql___local__mark__dirty(uint32_t);
+extern int __dtraceenabled_postgresql___local__mark__dirty(void);
+extern void __dtrace_postgresql___lock__endwait(int, int);
+extern int __dtraceenabled_postgresql___lock__endwait(void);
+extern void __dtrace_postgresql___lock__startwait(int, int);
+extern int __dtraceenabled_postgresql___lock__startwait(void);
+extern void __dtrace_postgresql___lwlock__acquire(int, int);
+extern int __dtraceenabled_postgresql___lwlock__acquire(void);
+extern void __dtrace_postgresql___lwlock__condacquire(int, int);
+extern int __dtraceenabled_postgresql___lwlock__condacquire(void);
+extern void __dtrace_postgresql___lwlock__condacquire__fail(int, int);
+extern int __dtraceenabled_postgresql___lwlock__condacquire__fail(void);
+extern void __dtrace_postgresql___lwlock__endwait(int, int);
+extern int __dtraceenabled_postgresql___lwlock__endwait(void);
+extern void __dtrace_postgresql___lwlock__release(int);
+extern int __dtraceenabled_postgresql___lwlock__release(void);
+extern void __dtrace_postgresql___lwlock__startwait(int, int);
+extern int __dtraceenabled_postgresql___lwlock__startwait(void);
+extern void __dtrace_postgresql___mark__dirty(uint32_t);
+extern int __dtraceenabled_postgresql___mark__dirty(void);
+extern void __dtrace_postgresql___multixact__checkpoint__entry(void);
+extern int __dtraceenabled_postgresql___multixact__checkpoint__entry(void);
+extern void __dtrace_postgresql___multixact__checkpoint__return(void);
+extern int __dtraceenabled_postgresql___multixact__checkpoint__return(void);
+extern void __dtrace_postgresql___slru__readpage__entry(uintptr_t, uint32_t, uint32_t, uint32_t);
+extern int __dtraceenabled_postgresql___slru__readpage__entry(void);
+extern void __dtrace_postgresql___slru__readpage__physical__entry(uintptr_t, char *, uint32_t, uint32_t);
+extern int __dtraceenabled_postgresql___slru__readpage__physical__entry(void);
+extern void __dtrace_postgresql___slru__readpage__physical__return(uint32_t, uint32_t, uint32_t);
+extern int __dtraceenabled_postgresql___slru__readpage__physical__return(void);
+extern void __dtrace_postgresql___slru__readpage__return(uint32_t);
+extern int __dtraceenabled_postgresql___slru__readpage__return(void);
+extern void __dtrace_postgresql___slru__readpage__ro(uintptr_t, uint32_t, uint32_t);
+extern int __dtraceenabled_postgresql___slru__readpage__ro(void);
+extern void __dtrace_postgresql___slru__writepage__entry(uintptr_t, uint32_t, uint32_t);
+extern int __dtraceenabled_postgresql___slru__writepage__entry(void);
+extern void __dtrace_postgresql___slru__writepage__physical__entry(uintptr_t, uint32_t, uint32_t);
+extern int __dtraceenabled_postgresql___slru__writepage__physical__entry(void);
+extern void __dtrace_postgresql___slru__writepage__physical__return(uint32_t, uint32_t, uint32_t);
+extern int __dtraceenabled_postgresql___slru__writepage__physical__return(void);
+extern void __dtrace_postgresql___slru__writepage__return(void);
+extern int __dtraceenabled_postgresql___slru__writepage__return(void);
+extern void __dtrace_postgresql___statement__start(char *);
+extern int __dtraceenabled_postgresql___statement__start(void);
+extern void __dtrace_postgresql___subtrans__checkpoint__entry(void);
+extern int __dtraceenabled_postgresql___subtrans__checkpoint__entry(void);
+extern void __dtrace_postgresql___subtrans__checkpoint__return(void);
+extern int __dtraceenabled_postgresql___subtrans__checkpoint__return(void);
+extern void __dtrace_postgresql___transaction__abort(int);
+extern int __dtraceenabled_postgresql___transaction__abort(void);
+extern void __dtrace_postgresql___transaction__commit(int);
+extern int __dtraceenabled_postgresql___transaction__commit(void);
+extern void __dtrace_postgresql___transaction__start(int);
+extern int __dtraceenabled_postgresql___transaction__start(void);
+extern void __dtrace_postgresql___twophase__checkpoint__entry(void);
+extern int __dtraceenabled_postgresql___twophase__checkpoint__entry(void);
+extern void __dtrace_postgresql___twophase__checkpoint__return(void);
+extern int __dtraceenabled_postgresql___twophase__checkpoint__return(void);
+extern void __dtrace_postgresql___xlog__checkpoint(uint32_t, uint32_t);
+extern int __dtraceenabled_postgresql___xlog__checkpoint(void);
+extern void __dtrace_postgresql___xlog__checkpoint__entry(uint32_t, uint32_t);
+extern int __dtraceenabled_postgresql___xlog__checkpoint__entry(void);
+extern void __dtrace_postgresql___xlog__checkpoint__return(void);
+extern int __dtraceenabled_postgresql___xlog__checkpoint__return(void);
+extern void __dtrace_postgresql___xlog__insert(uint32_t, uint32_t);
+extern int __dtraceenabled_postgresql___xlog__insert(void);
+extern void __dtrace_postgresql___xlog__switch(void);
+extern int __dtraceenabled_postgresql___xlog__switch(void);
 
-/*
- * Unless DTrace is explicitly enabled with --enable-dtrace, the PG_TRACE
- * macros will expand to no-ops.
- */
+#else
 
-#define PG_TRACE(name)
-#define PG_TRACE1(name, arg1)
-#define PG_TRACE2(name, arg1, arg2)
-#define PG_TRACE3(name, arg1, arg2, arg3)
-#define PG_TRACE4(name, arg1, arg2, arg3, arg4)
-#define PG_TRACE5(name, arg1, arg2, arg3, arg4, arg5)
-#endif   /* not ENABLE_DTRACE */
+#define	POSTGRESQL_AUTOVACUUM_RELATION(arg0, arg1, arg2, arg3)
+#define	POSTGRESQL_AUTOVACUUM_RELATION_ENABLED() (0)
+#define	POSTGRESQL_AUTOVACUUM_START(arg0, arg1)
+#define	POSTGRESQL_AUTOVACUUM_START_ENABLED() (0)
+#define	POSTGRESQL_BUFFER_FLUSH_ENTRY(arg0, arg1, arg2, arg3)
+#define	POSTGRESQL_BUFFER_FLUSH_ENTRY_ENABLED() (0)
+#define	POSTGRESQL_BUFFER_FLUSH_RETURN(arg0, arg1, arg2, arg3)
+#define	POSTGRESQL_BUFFER_FLUSH_RETURN_ENABLED() (0)
+#define	POSTGRESQL_BUFFER_SYNC_ENTRY(arg0, arg1)
+#define	POSTGRESQL_BUFFER_SYNC_ENTRY_ENABLED() (0)
+#define	POSTGRESQL_BUFFER_SYNC_RETURN(arg0, arg1, arg2)
+#define	POSTGRESQL_BUFFER_SYNC_RETURN_ENABLED() (0)
+#define	POSTGRESQL_BUFFER_SYNC_WRITTEN(arg0)
+#define	POSTGRESQL_BUFFER_SYNC_WRITTEN_ENABLED() (0)
+#define	POSTGRESQL_BUFFERS_CHECKPOINT_ENTRY(arg0)
+#define	POSTGRESQL_BUFFERS_CHECKPOINT_ENTRY_ENABLED() (0)
+#define	POSTGRESQL_BUFFERS_CHECKPOINT_RETURN()
+#define	POSTGRESQL_BUFFERS_CHECKPOINT_RETURN_ENABLED() (0)
+#define	POSTGRESQL_CLOG_CHECKPOINT_ENTRY()
+#define	POSTGRESQL_CLOG_CHECKPOINT_ENTRY_ENABLED() (0)
+#define	POSTGRESQL_CLOG_CHECKPOINT_RETURN()
+#define	POSTGRESQL_CLOG_CHECKPOINT_RETURN_ENABLED() (0)
+#define	POSTGRESQL_EXEC_AGG(arg0, arg1)
+#define	POSTGRESQL_EXEC_AGG_ENABLED() (0)
+#define	POSTGRESQL_EXEC_GROUP(arg0, arg1)
+#define	POSTGRESQL_EXEC_GROUP_ENABLED() (0)
+#define	POSTGRESQL_EXEC_HASH_MULTI(arg0)
+#define	POSTGRESQL_EXEC_HASH_MULTI_ENABLED() (0)
+#define	POSTGRESQL_EXEC_HASHJOIN(arg0)
+#define	POSTGRESQL_EXEC_HASHJOIN_ENABLED() (0)
+#define	POSTGRESQL_EXEC_LIMIT(arg0)
+#define	POSTGRESQL_EXEC_LIMIT_ENABLED() (0)
+#define	POSTGRESQL_EXEC_MATERIAL(arg0)
+#define	POSTGRESQL_EXEC_MATERIAL_ENABLED() (0)
+#define	POSTGRESQL_EXEC_MERGEJOIN(arg0)
+#define	POSTGRESQL_EXEC_MERGEJOIN_ENABLED() (0)
+#define	POSTGRESQL_EXEC_NESTLOOP(arg0)
+#define	POSTGRESQL_EXEC_NESTLOOP_ENABLED() (0)
+#define	POSTGRESQL_EXEC_SCAN(arg0, arg1, arg2)
+#define	POSTGRESQL_EXEC_SCAN_ENABLED() (0)
+#define	POSTGRESQL_EXEC_SETOP(arg0)
+#define	POSTGRESQL_EXEC_SETOP_ENABLED() (0)
+#define	POSTGRESQL_EXEC_SORT(arg0, arg1)
+#define	POSTGRESQL_EXEC_SORT_ENABLED() (0)
+#define	POSTGRESQL_EXEC_SUBPLAN_HASH(arg0)
+#define	POSTGRESQL_EXEC_SUBPLAN_HASH_ENABLED() (0)
+#define	POSTGRESQL_EXEC_SUBPLAN_SCAN(arg0)
+#define	POSTGRESQL_EXEC_SUBPLAN_SCAN_ENABLED() (0)
+#define	POSTGRESQL_EXEC_UNIQUE(arg0)
+#define	POSTGRESQL_EXEC_UNIQUE_ENABLED() (0)
+#define	POSTGRESQL_LOCAL_MARK_DIRTY(arg0)
+#define	POSTGRESQL_LOCAL_MARK_DIRTY_ENABLED() (0)
+#define	POSTGRESQL_LOCK_ENDWAIT(arg0, arg1)
+#define	POSTGRESQL_LOCK_ENDWAIT_ENABLED() (0)
+#define	POSTGRESQL_LOCK_STARTWAIT(arg0, arg1)
+#define	POSTGRESQL_LOCK_STARTWAIT_ENABLED() (0)
+#define	POSTGRESQL_LWLOCK_ACQUIRE(arg0, arg1)
+#define	POSTGRESQL_LWLOCK_ACQUIRE_ENABLED() (0)
+#define	POSTGRESQL_LWLOCK_CONDACQUIRE(arg0, arg1)
+#define	POSTGRESQL_LWLOCK_CONDACQUIRE_ENABLED() (0)
+#define	POSTGRESQL_LWLOCK_CONDACQUIRE_FAIL(arg0, arg1)
+#define	POSTGRESQL_LWLOCK_CONDACQUIRE_FAIL_ENABLED() (0)
+#define	POSTGRESQL_LWLOCK_ENDWAIT(arg0, arg1)
+#define	POSTGRESQL_LWLOCK_ENDWAIT_ENABLED() (0)
+#define	POSTGRESQL_LWLOCK_RELEASE(arg0)
+#define	POSTGRESQL_LWLOCK_RELEASE_ENABLED() (0)
+#define	POSTGRESQL_LWLOCK_STARTWAIT(arg0, arg1)
+#define	POSTGRESQL_LWLOCK_STARTWAIT_ENABLED() (0)
+#define	POSTGRESQL_MARK_DIRTY(arg0)
+#define	POSTGRESQL_MARK_DIRTY_ENABLED() (0)
+#define	POSTGRESQL_MULTIXACT_CHECKPOINT_ENTRY()
+#define	POSTGRESQL_MULTIXACT_CHECKPOINT_ENTRY_ENABLED() (0)
+#define	POSTGRESQL_MULTIXACT_CHECKPOINT_RETURN()
+#define	POSTGRESQL_MULTIXACT_CHECKPOINT_RETURN_ENABLED() (0)
+#define	POSTGRESQL_SLRU_READPAGE_ENTRY(arg0, arg1, arg2, arg3)
+#define	POSTGRESQL_SLRU_READPAGE_ENTRY_ENABLED() (0)
+#define	POSTGRESQL_SLRU_READPAGE_PHYSICAL_ENTRY(arg0, arg1, arg2, arg3)
+#define	POSTGRESQL_SLRU_READPAGE_PHYSICAL_ENTRY_ENABLED() (0)
+#define	POSTGRESQL_SLRU_READPAGE_PHYSICAL_RETURN(arg0, arg1, arg2)
+#define	POSTGRESQL_SLRU_READPAGE_PHYSICAL_RETURN_ENABLED() (0)
+#define	POSTGRESQL_SLRU_READPAGE_RETURN(arg0)
+#define	POSTGRESQL_SLRU_READPAGE_RETURN_ENABLED() (0)
+#define	POSTGRESQL_SLRU_READPAGE_RO(arg0, arg1, arg2)
+#define	POSTGRESQL_SLRU_READPAGE_RO_ENABLED() (0)
+#define	POSTGRESQL_SLRU_WRITEPAGE_ENTRY(arg0, arg1, arg2)
+#define	POSTGRESQL_SLRU_WRITEPAGE_ENTRY_ENABLED() (0)
+#define	POSTGRESQL_SLRU_WRITEPAGE_PHYSICAL_ENTRY(arg0, arg1, arg2)
+#define	POSTGRESQL_SLRU_WRITEPAGE_PHYSICAL_ENTRY_ENABLED() (0)
+#define	POSTGRESQL_SLRU_WRITEPAGE_PHYSICAL_RETURN(arg0, arg1, arg2)
+#define	POSTGRESQL_SLRU_WRITEPAGE_PHYSICAL_RETURN_ENABLED() (0)
+#define	POSTGRESQL_SLRU_WRITEPAGE_RETURN()
+#define	POSTGRESQL_SLRU_WRITEPAGE_RETURN_ENABLED() (0)
+#define	POSTGRESQL_STATEMENT_START(arg0)
+#define	POSTGRESQL_STATEMENT_START_ENABLED() (0)
+#define	POSTGRESQL_SUBTRANS_CHECKPOINT_ENTRY()
+#define	POSTGRESQL_SUBTRANS_CHECKPOINT_ENTRY_ENABLED() (0)
+#define	POSTGRESQL_SUBTRANS_CHECKPOINT_RETURN()
+#define	POSTGRESQL_SUBTRANS_CHECKPOINT_RETURN_ENABLED() (0)
+#define	POSTGRESQL_TRANSACTION_ABORT(arg0)
+#define	POSTGRESQL_TRANSACTION_ABORT_ENABLED() (0)
+#define	POSTGRESQL_TRANSACTION_COMMIT(arg0)
+#define	POSTGRESQL_TRANSACTION_COMMIT_ENABLED() (0)
+#define	POSTGRESQL_TRANSACTION_START(arg0)
+#define	POSTGRESQL_TRANSACTION_START_ENABLED() (0)
+#define	POSTGRESQL_TWOPHASE_CHECKPOINT_ENTRY()
+#define	POSTGRESQL_TWOPHASE_CHECKPOINT_ENTRY_ENABLED() (0)
+#define	POSTGRESQL_TWOPHASE_CHECKPOINT_RETURN()
+#define	POSTGRESQL_TWOPHASE_CHECKPOINT_RETURN_ENABLED() (0)
+#define	POSTGRESQL_XLOG_CHECKPOINT(arg0, arg1)
+#define	POSTGRESQL_XLOG_CHECKPOINT_ENABLED() (0)
+#define	POSTGRESQL_XLOG_CHECKPOINT_ENTRY(arg0, arg1)
+#define	POSTGRESQL_XLOG_CHECKPOINT_ENTRY_ENABLED() (0)
+#define	POSTGRESQL_XLOG_CHECKPOINT_RETURN()
+#define	POSTGRESQL_XLOG_CHECKPOINT_RETURN_ENABLED() (0)
+#define	POSTGRESQL_XLOG_INSERT(arg0, arg1)
+#define	POSTGRESQL_XLOG_INSERT_ENABLED() (0)
+#define	POSTGRESQL_XLOG_SWITCH()
+#define	POSTGRESQL_XLOG_SWITCH_ENABLED() (0)
 
-#endif   /* PG_TRACE_H */
+#endif
+
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _PG_TRACE_H_TMP */
